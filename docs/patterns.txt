Pattern Matching in Ubik ===============================================
Haldean Brown                                      First draft: May 2016
                                                  Last updated: May 2016

Pattern matching is the base conditional in Ubik; all other statements
with conditional behavior are implemented in terms of matches. In Ubik,
patterns are a syntactic literal (just like the literal "5" is a literal
integer). Behind the scenes, matches are compiled down to simple
predicate functions.

Patterns are constructed using the pattern operator "~", like so:

        ~ Pair x y

This creates a pattern that matches anything created with the pair
constructor, and also results in a local binding to x and y. When used
in conjunction with the match operator "?", like so:

        : fst
            ^ Pair a b -> a
            = \p -> ? p {
                ~ Pair x y => x
            }

Patterns are restricted to unpacking Algebraic Data Types (ADTs).
Another syntactic example:

        : shape-name
            ^ Shape -> String
            = \x -> ? x {
                ~ Circle center _ => concat "circle " (humanize center)
                ~ Rect lo hi => "rectangle"
            }

The ? operator takes an expression and a block containing a number of
case statements. The heads are evaluated in turn; if the head evaluates
to true, the tail of the case statement is executed and nothing after it
is.

The result of this is that any expression can be at the head of a case
statement, not just a pattern. Patterns are special heads which both
have a boolean evaluator and a resulting binding. Thus, the following is
totally legal:

        : is-more-than-10
            = num -> ? {
                num > 10 => "yes"
                _ => "no"
            }

_ is a special operator that always evaluates to true. Note that in
this example there is no match expression; for any cond block, the heads
of each case statement must either all be patterns or boolean values.
The _ operator can be used as both pattern and boolean, so it can be
used as a catch-all with both.

Just because the heads must all be patterns doesn't mean that the heads
need be pattern literals. The ~ operator is a function just like any
other; you can use it to create a pattern and then pass it around just
like a normal object. If you do not use a literal, though, then the
bindings are not created; you only get bindings with an in-place
literal.
