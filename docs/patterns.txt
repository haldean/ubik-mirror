Conditional blocks in Ubik =============================================
Haldean Brown                                      First draft: May 2016
                                                  Last updated: May 2016

Conditional blocks (cond-blocks) are the base of all control flow in
Ubik; all other statements with conditional behavior are implemented in
terms of cond-blocks. Cond-blocks can take two forms: pattern-matching
blocks and predicate blocks. Pattern matching blocks are like
switch-case statements on steroids; they allow you to match an object to
a set of patterns, and are the operation that give ADTs their expressive
power. Predicate blocks are more similar to the cond macro in Common
Lisp; they take a series of predicates along with the value of the
cond-block expression should each predicate be true.

In order to maintain the totality of the functions at play, each
cond-block is required to handle all possible cases of input. For
pattern blocks, this means that either all cases for the appropriate
type must be handled, and for predicate blocks, it means that there must
be a predicate involved which provably evalutes to true, always.

Cond-blocks are all expressed as curly-brace-enclosed blocks of case
statements; each case statement has a head and a tail, where the head is
that which may or may not evaluate to true or match the expression, and
the tail is the value of the block should the head evaluate to true.

For example, here is what a simple pattern matching block looks like; in
this example, Pair is a type with only one constructor, so only one
pattern is required to match all possible inputs:

        : fst
            ^ Pair a b -> a
            = \p -> ? p {
                ~ Pair x y => x
            }

Patterns are restricted to unpacking Algebraic Data Types (ADTs).
Another syntactic example, this time with an ADT with two constructors:

        ^ Shape
            = Circle Vec2 Number
            = Rect Vec2 Vec2

        : shape-name
            ^ Shape -> String
            = \x -> ? x {
                ~ Circle center _ => concat "circle " (humanize center)
                ~ Rect lo hi => "rectangle"
            }

For pattern blocks, the ? operator takes an expression and the block of
case statements. The heads are evaluated in turn; if the head evaluates
to true, the tail of the case statement is executed and nothing after it
is.

Predicate blocks look very similar; they are only missing the expression
to evaluate:

        : is-more-than-10
            = num -> ? {
                num > 10 => "yes"
                _ => "no"
            }

_ is a special operator that always evaluates to true and always matches
any expression.  The _ operator can be used as both pattern and boolean,
so it can be used as a catch-all with both pattern blocks and predicate
blocks.

