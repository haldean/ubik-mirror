Architecture of the Expel Runtime ======================================
Haldean Brown, Nov 2015


This document attempts to fully explain the implementation and behavior
of the Expel runtime. When the code and this document disagree, the code
is incorrect; on the other hand, don't trust anything in this document.


Runtime representations ------------------------------------------------

Expel is based on a simple primitive: unbalanced binary trees of 64-bit
values (called "words"). Everything is expressed in this way, from
integers to types to functions; this homogeneity of data representation
allows us to simplify otherwise-complicated tasks and has a satisfying
purity. Note that the in-memory representation is extremely close to the
on-disk representation of compiled Expel programs.

Each node in the tree has a left value, a right value, and a tag. Each
value can be one of two things: a pointer to another node or a word; the
tag tells you how to interpret the left and right values.


Tags

Tags are stored in a byte which is the bitwise union of the relevant
masks:

                0b00000001 (0x01): left child is a node
                0b00000010 (0x02): left child is a word
                0b00000100 (0x04): right child is a node
                0b00001000 (0x08): right child is a word

Thus, a node whose left value is a node and whose right value is a word
would have the tag `0b00001001`, or `0x09`.

Additionally, the relevant tag type is bitwise-ORed into the tag:

                0b00010000 (0x00): object is a tree
                0b00100000 (0x10): object is a graph
                0b00110000 (0x20): object is a URI

So a graph has tag `0x20` and a URI has tag `0x30`, and a tree whose
left is a node and whose right is a word has tag `0x19`.

Types

Types can be base types or derived types. Base types are special in that
they are identified only by an integer constant; derived types (quite
predictably) require quite a bit more information about the type itself.

The base types of Expel are a few flavors of integer, lists and tuples.
Each of these has a base type code and comes with a tree encoding. The
full list of base type codes is:

                         Code   Description
                     ....word   unsigned 64-bit integer
                     ...sword   signed 64-bit integer
                     ....list   homogenous list
                     ...tuple   fixed-length tuple
                     ..packed   packed list
                     ....type   type descriptor
                     .....uri   expel resource identifier
                     ..lambda   function
                     .nlambda   native function

Each type code is actually a word that contains the numeric equivalent
of a 8-byte string, with the first letter in the byte with the lowest
address. Note that periods in the above table stand in for space
characters (`0x20`).

The tree encoding of integer types is very simple; on its left is a word
containing the type code of the relevant integer type and on its right
is the representation of the value. The value representation is a word
in which the represented value is stored in the lowest bits.

The tree encoding of list types puts a list type descriptor on its left
and the value of the list on its right. The list type descriptor has a
constant word `list` on its left and a node representing the type of the
elements of the list on its right. Each item on the right of the list
should have a value on its left and either a node representing a list or
a word set to zero on its right; finding the zero-word is a sentinel
that the end of the list has been reached.

The tree encoding of tuple types is similar to lists; there's a tuple
type descriptor on the left and a tuple value on the right. The values
are cons cells just like lists. However, the type descriptor is more
complicated, as tuple elements are not homogenous. Instead, the type
descriptor is a node whose left is the constant word `tuple` and whose
right is a zero-word-terminated list of type encodings.

The tree encoding of packed list types is provided for better space
usage than a straight list would provide. The left type descriptor for a
packed list is a node whose left is the constant word `packed` and whose
right is the type of the elements of the list; this type is restricted
to be a built-in integral type or `char`. The right value of a packed
list is a node whose left is a word containing the number of items in
the list, and whose right is a list of packed values encoded as cons
cells, where each cell has a left of 8 bytes of packed data, and a right
that either points to the next node or a zero-word. If the data ends off
of an 8-byte boundary, the remaining bytes in the left word are zeroed;
it is up to the user of the tree value to respect the length given in
the first word of the value.

Strings are stored as UTF-8 and are represented as packed lists of
bytes; the represented string is the concatenation of all left values in
the list. Note that this means that each individual left value may in
fact be poorly-formed UTF-8, as a multibyte code point may be split
across words.

A type descriptor describes a type on its own; its left is the constant
word `type` and its right is the descriptor itself. Anything that would
appear on the left of a typed value is a type descriptor value, and
could appear on the right of a type node.

A resource identifier is how all entities within the expel runtime are
identified. Resources all have a name, author, version and scope; all of
these are encoded in the URI tree. The left of a URI tree is the
constant word `uri`, and the right is a cons-cell list, where the first
element in the list is the name of the resource as a packed string, the
second element in the list is the author (also as a packed string), the
third item is a 64-bit integer representing the version number and the
final element is a 64-bit integer represending the scope of the
resource. The meanings of these fields will be covered in the Bindings
section below.

Function types (`lambda` and `nlambda`) work slightly differently; the
types are stored as tree values but the function bodies are stored as...
what?


Building logic ---------------------------------------------------------

Logic in Expel is encoded in a directed acyclic graph of computations
(DAGC); nodes in this graph then reference values stored as trees. There
are four kinds of nodes in a DAGC:

        `apply`     Points to a node with a function value and a node with
                    an argument. Applies the argument to the function
                    value. If the function is then fully applied the value
                    of the node is the result of the function; if the
                    function is partially applied the value of the node is
                    a function that has an arity of one fewer than the
                    input function.
        `const`     A constant type and value.
        `load`      A load operation. Has a required URI and an optional
                    dependent store; the URI references where the value
                    should come from and the dependent store adds a
                    dependency from the load to that store.
        `store`     A store operation. Has a URI and a reference to a node
                    with a value, and stores the given value at that URI.
        `input`     The input to a DAGC.
        `dispatch`  Reference to a different DAGC.

Each individual DAGC represents a function; each DAGC contains an input
node for each of the function's arguments, and a single terminal node
that represents the function's result. The minimal set of nodes required
to evaluate the terminal node is found, and all nodes in that set are
evaluated in turn. This gives the result for the DAGC.

Logic is then built up by creating a number of graphs and referencing
them from each other. When a `dispatch` node is applied, a copy of the
referenced DAGC is made and that DAGC's `input` nodes are completed.
Once all required input nodes have been completed, the DAGC can be
evaluated.

Encoding in-flight and at-rest -----------------------------------------

Trees have a single binary storage format that is used for network
operations and for on-disk storage. The format begins with a header, and
then contains a number of encoded graphs.

All numerically-encoded data is stored in big-endian ("network") byte
order, which means the most significant byte comes first.

The header has the following fields:

        Byte index   Field
               0-3   The constant bytes 0x65 0x78 0x70 0x6C ("expl")
               4-7   The version number of the encoding format, as a
                     big-endian 4-byte unsigned integer.
              8-15   The number of graphs in the file.

The version of the encoding specified in this document is 1, and thus
bytes 4-7 should be 0x00000001. The decoding proceeds by concatenating a
number of graph encodings. Each graph that is encoded is identified by
its index in the file.

The graph encoding has a header of its own:

        Byte index   Field
               0-7   The number of nodes in the graph

Following the graph header, the specified number of node encodings
follows. The order of encoding matters; each node is identified by other
nodes by its index.

A node is encoded by a type-independent header followed by a
type-dependent body. The type-independent node header has the following
format:

        Byte index   Field
               0-7   Node type (word-encoded)
                 8   Set to 0x01 if the node is a terminal node, meaning
                     that its value is intended as an output of
                     computation. Set to 0x00 otherwise.
              9-11   Unused

Once the header has been loaded, the type-dependent decoding of the body
is given.

Nodes with node type `   apply` have the following body:

        Byte index   Field
               0-7   Node index of function node
              8-15   Node index of argument node

Nodes with node type `    load` have the following body:

        Byte index   Field
               0-7   Node index of dependent store
              8...   Tree-encoded URI

If the load has no dependent store, bytes 0-7 should all be set to 0xFF.

Nodes with node type `   store` have the following body:

        Byte index   Field
               0-7   Node index of value node
              8...   Tree-encoded URI

Nodes with node type `   const` have the following subheader:

        Byte index   Field
               0-7   The subtype of the associated value (either
                     `cvalue` or `cgraph`) which informs whether this
                     constant points at a DAGC or a tree.
              8...   The tree-encoded type of the constant

Then, depending on the associated subtype, this header is either
followed by a tree-encoded value (if the subtype is `cvalue`) or
contains a word-encoded index of another graph in the encoding (if the
subtype is `cgraph`).

Nodes with node type `   input` have the following body:

        Byte index   Field
               0-7   Argument index of the node
              8...   The tree-encoded type requirement on the argument

The tree encoding proceeds as follows: Begin with the root of the tree
to be encoded. The node's 8-bit tag is written to the stream, followed
by the encoding of its left child, then its right child. If a child is a
value, the value is written to the stream in little-endian format as an
8-byte integer. If a child is a node, recurse and apply this same
operation.

Tree decoding proceeds in much the same way: Take a byte off of the head
of the stream. If the byte indicates the left is a node, recurse. If it
indicates the left is a value, read the value as a little-endian 8-byte
integer. Repeat the same operation for the right node.
